// LIGO output generated by archetype 0.1.14

// contract: crowsurance

// To generate origination storage string please execute the following command:
// ligo compile-storage crowsurance.ligo main 'record insuring_deadline = now; expiration = now; initial_balance = 0mutez; elapsed_balance = 0mutez; insured_users = 0; state = state_creation; user_assets = (map [] : map(address, user_storage)); wcell_assets = (map [] : map(int, wcell_storage)); event_cell_assets = (set [] : set(int)); event_assets = (map [] : map(string, event_storage)) end'

const contract_manager : address = (("tz15P69BXJYAURaznhvN1k1KmuhR6P52hw6x" : address) : address)

const event_oracle : address = (("tz15P69BXJYAURaznhvN1k1KmuhR6P52hw6x" : address) : address)

const verify_oracle : address = (("tz15P69BXJYAURaznhvN1k1KmuhR6P52hw6x" : address) : address)

const min_premium : tez = 1000000mutez

const max_mag : (int * int) = (12, 1)

const min_mag : (int * int) = (5, 1)

const insuring_duration : int = 604800

const insured_duration : int = 2419200






const state_creation : int = 0

const state_insuring : int = 1

const state_insured : int = 2

const state_expired : int = 3

const event_type_earthquake : int = 0

const event_type_flood : int = 1

const event_type_wildfire : int = 2

const event_type_draught : int = 3

const event_type_hurricane : int = 4

const event_type_eruption : int = 5

type user is record [
  addr : address;
  cell : int;
  bal : tez;
  premium : tez;
  verified : bool;
]

type user_storage is record [
  cell : int;
  bal : tez;
  premium : tez;
  verified : bool;
]

type wcell is record [
  idx : int;
  users : list(address);
]

type wcell_storage is record [
  users : list(address);
]

type event_cell is record [
  cid : int;
]

type event is record [
  eid : string;
  etype : int;
  mag : (int * int);
  cells : list(int);
  affected : list(address);
]

type event_storage is record [
  etype : int;
  mag : (int * int);
  cells : list(int);
  affected : list(address);
]

type storage_type is record [
  insuring_deadline : timestamp;
  expiration : timestamp;
  initial_balance : tez;
  elapsed_balance : tez;
  insured_users : int;
  state : int;
  user_assets : map(address, user_storage);
  wcell_assets : map(int, wcell_storage);
  event_cell_assets : set(int);
  event_assets : map(string, event_storage);
]

type action_start is unit

type action_endInsuring is unit

type action_endInsured is unit

type action_insureUser is record [
  pos : int;
]

type action_verifyUser is record [
  uaddr : address;
  wc : int;
]

type action_withdraw is unit

type action_triggerEvent is record [
  ed : string;
  emg : (int * int);
  et : event_type;
  cl : list(event_cell);
]

type action is
  | Start of action_start
  | EndInsuring of action_endInsuring
  | EndInsured of action_endInsured
  | InsureUser of action_insureUser
  | VerifyUser of action_verifyUser
  | Withdraw of action_withdraw
  | TriggerEvent of action_triggerEvent

(* API function *)

type op_cmp is
| OpCmpLt of unit
| OpCmpLe of unit
| OpCmpGt of unit
| OpCmpGe of unit

function rat_cmp (const op : op_cmp; const lhs : (int * int); const rhs : (int * int)) : bool is
  begin
    const a : int = lhs.0 * rhs.1;
    const b : int = lhs.1 * rhs.0;
    const pos : bool = lhs.1 * rhs.1 > 0;
    var r : bool := False;
    case op of
    | OpCmpLt -> if pos then r := a <  b else r := a >  b
    | OpCmpLe -> if pos then r := a <= b else r := a >= b
    | OpCmpGt -> if pos then r := a >  b else r := a <  b
    | OpCmpGe -> if pos then r := a >= b else r := a <= b
    end
  end with r

type op_arith is
| OpArithPlus  of unit
| OpArithMinus of unit
| OpArithMult  of unit
| OpArithDiv   of unit

function rat_arith (const op : op_arith; const lhs : (int * int); const rhs : (int * int)) : (int * int) is
  begin
    const r : (int * int) =
    case op of
    | OpArithPlus  -> (lhs.0 * rhs.1 + rhs.0 * lhs.1, lhs.1 * rhs.1)
    | OpArithMinus -> (lhs.0 * rhs.1 - rhs.0 * lhs.1, lhs.1 * rhs.1)
    | OpArithMult  -> (lhs.0 * rhs.0, lhs.1 * rhs.1)
    | OpArithDiv   -> (lhs.0 * rhs.1, lhs.1 * rhs.0)
    end
  end with r

function rat_tez (const c : (int * int); const t : tez) : tez is
begin
  const r : tez = abs(c.0) * t / abs(c.1);
  end with r

function get_user (const s : storage_type; const key : address) : user is
  begin
    const a : user_storage = get_force(key, s.user_assets);
    const res : user = record[addr = key; cell = a.cell; bal = a.bal; premium = a.premium; verified = a.verified]
  end with (res)

function count_user (const l : list(address)) : int is
  block { skip }
  with int(size(l))

function sum_user_0 (const s : storage_type; const l : list(address)) : tez is
  begin
    function aggregate (const accu : tez; const i : address) : tez is
      block {
        const a : user = get_user(s, i);
      } with (accu + (a.premium));
  end with (list_fold(aggregate, l, 0))

function add_user (const s : storage_type; const a : user) : storage_type is
  begin
    const key : address = a.addr;
    const map_local : map(address, user_storage) = s.user_assets;
    if map_mem(key, map_local) then failwith ("key already exists") else skip;
    const asset : user_storage = record[cell = a.cell; bal = a.bal; premium = a.premium; verified = a.verified];
    map_local[key] := asset;
    s.user_assets := map_local;
  end with (s)




function select_user_0 (const s : storage_type; const l : list(address)) : list(address) is
  begin
    function aggregate (const accu : list(address); const i : address) : list(address) is
      begin
        const the : user = get_user(s, i);
        end with (if (the.verified) then cons(the.addr, accu) else accu);
    end with (list_fold(aggregate, l, (nil : list(address))))

function contains_user (const l : list(address); const key : address) : bool is
  begin
  function aggregate (const accu : bool; const v : address) : bool is block { skip } with (accu or v = key);
  end with list_fold(aggregate, l, False)



function col_to_keys_user (const s : storage_type) : list(address) is
 begin
 function to_keys (const accu : list(address); const v : (address * user_storage)) : list(address) is block { skip } with cons(v.0, accu);
 function rev     (const accu : list(address); const v : address) : list(address) is block { skip } with cons(v, accu);
 var res : list(address) := (nil : list(address));
 res := map_fold(to_keys, s.user_assets, res);
 res := list_fold(rev, res, (nil : list(address)));
 end with res

function get_wcell (const s : storage_type; const key : int) : wcell is
  begin
    const a : wcell_storage = get_force(key, s.wcell_assets);
    const res : wcell = record[idx = key; users = a.users]
  end with (res)

function add_wcell (const s : storage_type; const a : wcell) : storage_type is
  begin
    const key : int = a.idx;
    const map_local : map(int, wcell_storage) = s.wcell_assets;
    if map_mem(key, map_local) then failwith ("key already exists") else skip;
    const asset : wcell_storage = record[users = a.users];
    map_local[key] := asset;
    s.wcell_assets := map_local;
  end with (s)

function add_wcell_users (const s : storage_type; const a : wcell; const b : user) : storage_type is
  begin
    const asset_key : int = a.idx;
    const asset_val : wcell = get_wcell(s, asset_key);
    if not map_mem(b.addr, s.user_assets) then failwith ("key does not exist") else skip;
    a.users := cons(b.addr, asset_val.users);
    s.wcell_assets[asset_key] := record[users = a.users];
  end with (s)

function contains_wcell (const l : list(int); const key : int) : bool is
  begin
  function aggregate (const accu : bool; const v : int) : bool is block { skip } with (accu or v = key);
  end with list_fold(aggregate, l, False)

function col_to_keys_wcell (const s : storage_type) : list(int) is
 begin
 function to_keys (const accu : list(int); const v : (int * wcell_storage)) : list(int) is block { skip } with cons(v.0, accu);
 function rev     (const accu : list(int); const v : int) : list(int) is block { skip } with cons(v, accu);
 var res : list(int) := (nil : list(int));
 res := map_fold(to_keys, s.wcell_assets, res);
 res := list_fold(rev, res, (nil : list(int)));
 end with res

function count_event_cell (const l : list(int)) : int is
  block { skip }
  with int(size(l))

function add_event_cell (const s : storage_type; const a : event_cell) : storage_type is
  begin
    const key : int = a.cid;
    if set_mem(key, s.event_cell_assets) then failwith ("key already exists") else skip;
    s.event_cell_assets := set_add(key, s.event_cell_assets);
  end with (s)

function add_event (const s : storage_type; const a : event) : storage_type is
  begin
    const key : string = a.eid;
    const map_local : map(string, event_storage) = s.event_assets;
    if map_mem(key, map_local) then failwith ("key already exists") else skip;
    const asset : event_storage = record[etype = a.etype; mag = a.mag; cells = a.cells; affected = a.affected];
    map_local[key] := asset;
    s.event_assets := map_local;
  end with (s)

function add_event_affected (const s : storage_type; const a : event; const b : user) : storage_type is
  begin
    const asset_key : string = a.eid;
    const asset_val : event = get_event(s, asset_key);
    if not map_mem(b.addr, s.user_assets) then failwith ("key does not exist") else skip;
    a.affected := cons(b.addr, asset_val.affected);
    s.event_assets[asset_key] := record[etype = a.etype; mag = a.mag; cells = a.cells; affected = a.affected];
  end with (s)

function contains_event (const l : list(string); const key : string) : bool is
  begin
  function aggregate (const accu : bool; const v : string) : bool is block { skip } with (accu or v = key);
  end with list_fold(aggregate, l, False)

function col_to_keys_event (const s : storage_type) : list(string) is
 begin
 function to_keys (const accu : list(string); const v : (string * event_storage)) : list(string) is block { skip } with cons(v.0, accu);
 function rev     (const accu : list(string); const v : string) : list(string) is block { skip } with cons(v, accu);
 var res : list(string) := (nil : list(string));
 res := map_fold(to_keys, s.event_assets, res);
 res := list_fold(rev, res, (nil : list(string)));
 end with res


function add_shallow_wcell(const s_ : storage_type; const wcell : wcell; const wcell_users : list(user)) : storage_type is
  begin
  s_ := add_wcell (s_, wcell);
  for user in list (wcell_users) block {
    s_ := add_user (s_, user) }
  
  end with (s_)

function add_shallow_event(const s_ : storage_type; const event : event; const event_cells : list(event_cell); const event_affected : list(user)) : storage_type is
  begin
  s_ := add_event (s_, event);
  for event_cell in list (event_cells) block {
    s_ := add_event_cell (s_, event_cell) }
  ;
  for user in list (event_affected) block {
    s_ := add_user (s_, user) }
  
  end with (s_)

function start(const action : action_start; const s_ : storage_type) : (list(operation) * storage_type) is
  begin
  if (not (sender = (contract_manager : address))) then failwith ("invalid caller") else skip;
  if s_.state = state_creation then block {
    s_.insuring_deadline := (now) + (insuring_duration);
    s_.expiration := ((now) + (insuring_duration)) + (insured_duration);
    s_.state := state_insuring }
  else 
    failwith ("invalid state")
  end with ((nil : list(operation)), s_)

function endInsuring(const action : action_endInsuring; const s_ : storage_type) : (list(operation) * storage_type) is
  begin
  if (not (sender = (contract_manager : address))) then failwith ("invalid caller") else skip;
  if s_.state = state_insuring then 
    if  
      now >= s_.insuring_deadline then block {
      const vrf : list(address) = select_user_0 (s_, col_to_keys_user (s_)) ;
      s_.elapsed_balance := sum_user_0 (s_, vrf);
      s_.initial_balance := s_.elapsed_balance;
      s_.insured_users := count_user (vrf);
      s_.state := state_insured }
    else
      skip
  else 
    failwith ("invalid state")
  end with ((nil : list(operation)), s_)

function endInsured(const action : action_endInsured; const s_ : storage_type) : (list(operation) * storage_type) is
  begin
  if (not (sender = (contract_manager : address))) then failwith ("invalid caller") else skip;
  if s_.state = state_insured then 
    if  
      now >= s_.expiration then 
      s_.state := state_expired
    else
      skip
  else 
    failwith ("invalid state")
  end with ((nil : list(operation)), s_)

function insureUser(const action : action_insureUser; const s_ : storage_type) : (list(operation) * storage_type) is
  begin
  if (not (s_.state = state_insuring)) then failwith ("require i0 failed") else skip;
  if (not (amount >= min_premium)) then failwith ("require i1 failed") else skip;
  if (not (not (contains_user (col_to_keys_user (s_), sender)))) then failwith ("require i2 failed") else skip;
  s_ := add_user (s_, (record addr = sender; cell = action.pos; bal = 0mutez; premium = amount; verified = False; end : user))
  end with ((nil : list(operation)), s_)

function verifyUser(const action : action_verifyUser; const s_ : storage_type) : (list(operation) * storage_type) is
  begin
  if (not (sender = (verify_oracle : address))) then failwith ("invalid caller") else skip;
  if (not (s_.state = state_insuring)) then failwith ("require v0 failed") else skip;
  if (not (contains_user (col_to_keys_user (s_), action.uaddr))) then failwith ("require v1 failed") else skip;
  const tmp_0 : user = get_user (s_, action.uaddr) ;
  if (not (tmp_0.cell = action.wc)) then failwith ("require v2 failed") else skip;
  const tmp_0 : wcell = get_wcell (s_, action.wc) ;
  if (not ((not (contains_wcell (col_to_keys_wcell (s_), action.wc))) or ((contains_wcell (col_to_keys_wcell (s_), action.wc)) and (not (contains_user (tmp_0.users, action.uaddr)))))) then failwith ("require v3 failed") else skip;
  const u : user = get_user (s_, action.uaddr) ;
  const key_user_ : address = action.uaddr;
  const user_ : user_storage = get_force(key_user_, s_.user_assets);
  s_.user_assets[key_user_] := user_ with record [verified = True];
  if  
    contains_wcell (col_to_keys_wcell (s_), u.cell) then 
    s_ := add_shallow_wcell (s_, (record idx = u.cell; users = (nil : list(address)); end : wcell), (nil : list(user)))
  else
    skip;
  s_ := add_wcell_users (s_, get_wcell (s_, u.cell), get_user (s_, action.uaddr))
  end with ((nil : list(operation)), s_)

function withdraw(const action : action_withdraw; const s_ : storage_type) : (list(operation) * storage_type) is
  begin
  var ops_ : list(operation) := (nil : list(operation));
  if (not (s_.state = state_expired)) then failwith ("require w0 failed") else skip;
  if (not (contains_user (col_to_keys_user (s_), sender))) then failwith ("require w1 failed") else skip;
  const tmp_0 : user = get_user (s_, sender) ;
  if (not (tmp_0.verified)) then failwith ("require w2 failed") else skip;
  const tmp_0 : user = get_user (s_, sender) ;
  if (not (tmp_0.bal > 0mutez)) then failwith ("require w3 failed") else skip;
  const tmp_0 : user = get_user (s_, sender) ;
  if (not (balance >= tmp_0.bal)) then failwith ("require w4 failed") else skip;
  const key_user_ : address = sender;
  const user_ : user_storage = get_force(key_user_, s_.user_assets);
  s_.user_assets[key_user_] := user_ with record [bal = 0mutez];
  const tmp_0 : user = get_user (s_, sender) ;
  ops_ := cons(transaction(unit, tmp_0.bal, (get_contract((sender : address)) : contract(unit))), ops_)
  end with (ops_, s_)

function triggerEvent(const action : action_triggerEvent; const s_ : storage_type) : (list(operation) * storage_type) is
  begin
  if (not (sender = (event_oracle : address))) then failwith ("invalid caller") else skip;
  if (not (s_.state = state_insured)) then failwith ("require t0 failed") else skip;
  if (not (count_event_cell (action.cl) > 0)) then failwith ("require t1 failed") else skip;
  if (not (not (contains_event (col_to_keys_event (s_), action.ed)))) then failwith ("require t2 failed") else skip;
  if (not ((rat_cmp (OpCmpGt(unit), action.emg, min_mag)) and (rat_cmp (OpCmpLt(unit), action.emg, max_mag)))) then failwith ("require t3 failed") else skip;
  const ev : event = (record eid = action.ed; etype = action.et; mag = action.emg; cells = action.cl; affected = (nil : list(address)); end : event) ;
  const ev_1 : list(user) = (nil : list(user)) ;
  for c in list (action.cl) block {
    const c : event_cell = get_force(c, action.cl_values) ;
    const tmp_0 : wcell = get_wcell (s_, c.cid) ;
    for ac in list (tmp_0.users) block {
      const ac : user = get_user (s_, ac) ;
      s_ := add_event_affected (s_, ev, ac) }
     }
  ;
  const afct_premium : tez = sum_user_0 (s_, ev.affected) ;
  for iu in list (ev.affected) block {
    const iu : user = get_user (s_, iu) ;
    const nbal : tez = (iu.bal) + (rat_tez (rat_arith (OpArithMinus(unit), action.emg, min_mag), iu.premium)) ;
    const key_user_ : address = iu.addr;
    const user_ : user_storage = get_force(key_user_, s_.user_assets);
    s_.user_assets[key_user_] := user_ with record [bal = nbal];
    s_.elapsed_balance := (s_.elapsed_balance) - (nbal) }
  ;
  s_ := add_shallow_event (s_, ev, ev_1)
  end with ((nil : list(operation)), s_)

function main(const action : action ; const s_ : storage_type) : (list(operation) * storage_type) is
  block {skip} with
  case action of
  | Start (a_) -> start(a_, s_)
  | EndInsuring (a_) -> endInsuring(a_, s_)
  | EndInsured (a_) -> endInsured(a_, s_)
  | InsureUser (a_) -> insureUser(a_, s_)
  | VerifyUser (a_) -> verifyUser(a_, s_)
  | Withdraw (a_) -> withdraw(a_, s_)
  | TriggerEvent (a_) -> triggerEvent(a_, s_)
  end



