(* Scaml output generated by archetype 0.1.14 *)

(* contract: crowsurance *)

open SCaml














type state =
  | Creation
  | Insuring
  | Insured
  | Expired

type event_type =
  | Earthquake
  | Flood
  | Wildfire
  | Draught
  | Hurricane
  | Eruption

type user = {
  addr : address;
  cell : int;
  bal : tz;
  premium : tz;
  verified : bool;
}

type wcell = {
  idx : int;
  users : address list;
}

type event_cell = {
  cid : int;
}

type event = {
  eid : string;
  etype : event_type;
  mag : rational;
  cells : int list;
  affected : address list;
}

type storage = {
  contract_manager : address;
  event_oracle : address;
  verify_oracle : address;
  min_premium : tz;
  max_mag : rational;
  min_mag : rational;
  insuring_duration : duration;
  insured_duration : duration;
  insuring_deadline : date;
  expiration : date;
  initial_balance : tz;
  elapsed_balance : tz;
  insured_users : int;
  state : state;
  user_assets : (address, user) map;
  wcell_assets : (int, wcell) map;
  event_cell_assets : (int, event_cell) map;
  event_assets : (string, event) map;
}

(* API function *)
let sum_user (s, l : storage * address list) : tz =
  List.fold_left (fun accu k ->
      let x =
        match Map.get k s.user_assets with
        | Some v -> v
        | _ -> failwith "not_found"
      in
      accu + x
    ) (Int 0) l

let select_user (s, l, p : storage * address list * (user -> bool)) : address list =
  List.fold_left (fun accu x ->
      let a = get_user (s, x) in
      if p a
      then a.addr::accu
      else accu
    ) [] l

let count_event (l : string list) : int =
  List.length l


let add_shallow_wcell (_s, wcell, wcell_users : storage * wcell * user list) : storage =
  let _s : storage = add_wcell (_s, wcell) in
  List.fold_left (fun (_s) user ->
      add_user (_s, user)) (_s) (wcell_users)
  

let add_shallow_event (_s, event, event_cells, event_affected : storage * event * event_cell list * user list) : storage =
  let _s : storage = add_event (_s, event) in
  let _s : storage = List.fold_left (fun (_s) event_cell ->
      add_event_cell (_s, event_cell)) (_s) (event_cells)
   in
  List.fold_left (fun (_s) user ->
      add_user (_s, user)) (_s) (event_affected)
  

let [@entry name="start"] start () (_s : storage) : operation list * storage =
  let _ops : operation list = [] in
  (if not (Global.get_sender () = (_s.contract_manager : address)) then failwith "invalid caller";
   match _s.state with
   | Creation -> (s.insuring_deadline := Global.get_now () + _s.insuring_duration;
                  s.expiration := Global.get_now () + _s.insuring_duration + _s.insured_duration;
                  state_ = Insuring)
     | _ -> failwith "invalid state";
   (_ops, _s))

let [@entry name="endInsuring"] endInsuring () (_s : storage) : operation list * storage =
  let _ops : operation list = [] in
  (if not (Global.get_sender () = (_s.contract_manager : address)) then failwith "invalid caller";
   match _s.state with
   | Insuring -> if Global.get_now () >= _s.insuring_deadline then 
                   (let vrf : address list = select_user (_s, col_to_keys_user (_s), fun the -> (the).verified) in
                    (s.elapsed_balance := sum_user (_s, (the).premium);
                     s.initial_balance := _s.elapsed_balance;
                     s.insured_users := count_user (vrf));
                    state_ = Insured;
                    (_s)) 
                 else 
                   ((_s)) 
     | _ -> failwith "invalid state";
   (_ops, _s))

let [@entry name="endInsured"] endInsured () (_s : storage) : operation list * storage =
  let _ops : operation list = [] in
  (if not (Global.get_sender () = (_s.contract_manager : address)) then failwith "invalid caller";
   match _s.state with
   | Insured -> if Global.get_now () >= _s.expiration then 
                  (state_ = Expired;
                   (_s)) 
                else 
                  ((_s)) 
     | _ -> failwith "invalid state";
   (_ops, _s))

let [@entry name="insureUser"] insureUser (pos : int) (_s : storage) : operation list * storage =
  let _ops : operation list = [] in
  (if not (_s.state = Insuring) then failwith "require i0 failed";
   if not (Global.get_amount () >= _s.min_premium) then failwith "require i1 failed";
   if not (not (contains_user (col_to_keys_user (_s), Global.get_sender ()))) then failwith "require i2 failed";
   let _s : storage = add_user (_s, { addr = Global.get_sender (); cell = pos; bal = 0; premium = Global.get_amount (); verified = false }) in
   (_ops, _s))

let [@entry name="verifyUser"] verifyUser (uaddr, wc : address * int) (_s : storage) : operation list * storage =
  let _ops : operation list = [] in
  (if not (Global.get_sender () = (_s.verify_oracle : address)) then failwith "invalid caller";
   if not (_s.state = Insuring) then failwith "require v0 failed";
   if not (contains_user (col_to_keys_user (_s), uaddr)) then failwith "require v1 failed";
   if not ((get_user (_s, uaddr)).cell = wc) then failwith "require v2 failed";
   if not ((not (contains_wcell (col_to_keys_wcell (_s), wc))) || ((contains_wcell (col_to_keys_wcell (_s), wc)) && (not (contains_user ((get_wcell (_s, wc)).users, uaddr))))) then failwith "require v3 failed";
   let _s : storage = let u : user = get_user (_s, uaddr) in
   let _s : storage = let k_ : address = uaddr in
   let user_ : user = get_user (_s, k_) in
   let user_ : user = { addr = (user_).addr; cell = (user_).cell; bal = (user_).bal; premium = (user_).premium; verified = true } in
   set_user (_s, k_, user_) in
   let _s : storage = if contains_wcell (col_to_keys_wcell (_s), (u).cell) then 
                        add_shallow_wcell (_s, { idx = (u).cell; users = [] }, []) 
                      else 
                        (_s)  in
   add_wcell_users (_s, get_wcell (_s, (u).cell), get_user (_s, uaddr)) in
   (_ops, _s))

let [@entry name="withdraw"] withdraw () (_s : storage) : operation list * storage =
  let _ops : operation list = [] in
  (if not (_s.state = Expired) then failwith "require w0 failed";
   if not (contains_user (col_to_keys_user (_s), Global.get_sender ())) then failwith "require w1 failed";
   if not ((get_user (_s, Global.get_sender ())).verified) then failwith "require w2 failed";
   if not ((get_user (_s, Global.get_sender ())).bal > 0) then failwith "require w3 failed";
   if not (Global.get_balance () >= (get_user (_s, Global.get_sender ())).bal) then failwith "require w4 failed";
   let _s : storage = let k_ : address = Global.get_sender () in
   let user_ : user = get_user (_s, k_) in
   let user_ : user = { addr = (user_).addr; cell = (user_).cell; bal = 0; premium = (user_).premium; verified = (user_).verified } in
   set_user (_s, k_, user_) in
   let (_s, _ops) : operation list * storage = add_list (_ops, transfer (get_user (_s, Global.get_sender ())).bal to cast_address_address(Global.get_sender ())) in
   (_ops, _s))

let [@entry name="triggerEvent"] triggerEvent (ed, emg, et, cl : string * rational * event_type * event_cell list) (_s : storage) : operation list * storage =
  let _ops : operation list = [] in
  (if not (Global.get_sender () = (_s.event_oracle : address)) then failwith "invalid caller";
   if not (_s.state = Insured) then failwith "require t0 failed";
   if not (count_event_cell (cl) > (Int 0)) then failwith "require t1 failed";
   if not (not (contains_event (col_to_keys_event (_s), ed))) then failwith "require t2 failed";
   if not ((emg > _s.min_mag) && (emg < _s.max_mag)) then failwith "require t3 failed";
   let _s : storage = let ev : event = { eid = ed; etype = et; mag = emg; cells = cl; affected = [] } in
   let ev_1 : user list = [] in
   let _s : storage = List.fold_left (fun (_s) c ->
       let c : event_cell = (match Map.get (c) (cl_values) with | Some x -> x | None -> failwith "event_cell not_found") in
       List.fold_left (fun (_s) ac ->
           let ac : user = get_user (_s, ac) in
           add_event_affected (_s, ev, ac)) (_s) ((get_wcell (_s, (c).cid)).users)
       ) (_s) (cl)
    in
   let afct_premium : tz = sum_user (_s, (the).premium) in
   let _s : storage = List.fold_left (fun (_s) iu ->
       (let iu : user = get_user (_s, iu) in
        let nbal : tz = (iu).bal + emg - _s.min_mag * (iu).premium in
        let _s : storage = let user_ : user = iu in
        let user_ : user = { addr = (user_).addr; cell = (user_).cell; bal = nbal; premium = (user_).premium; verified = (user_).verified } in
        set_user (_s, (iu).addr, user_) in
        s.elapsed_balance -= nbal;
        (_s))) (_s) ((ev).affected)
    in
   add_shallow_event (_s, ev, ev_1) in
   (_ops, _s))


